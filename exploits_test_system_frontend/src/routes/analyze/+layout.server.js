

/** @type {import('./$types').PageLoad} */

import { linear } from 'svelte/easing';
import { demos_st, codes_st, desc_and_rec_st, rows_st } from '$lib/stores/dataStores.js';
import { get } from 'svelte/store';

export function load({ params }) {
    let demos = get(demos_st);
    let codes = get(codes_st);
    let desc_and_rec = get(desc_and_rec_st);
    let rows = get(rows_st);

    //console.log(codes[3]);
    //console.log(rows);
    //console.log(desc_and_rec[1]);
    console.log(desc_and_rec[3]);

    let row_params = [];

    let vulnerability;
    let severity;

    let filePath = "Unknown";
    let startLine = "Unknown";

    Object.entries(rows).map(([key, value]) => {
        const vulnerabilityMatch = value.match(/Vulnerability=(.*?), Severity=/);
        const severityMatch = value.match(/Severity=(.*?), Project/);
        const locationMatch = value.match(/Location=\{(.*?)\}/);
    
        vulnerability = vulnerabilityMatch ? vulnerabilityMatch[1] : "Unknown";
        severity = severityMatch ? severityMatch[1] : "Unknown";
    
        if (locationMatch) {
            try {
                // Preprocess the string to make it JSON-compatible
                const locationString = locationMatch[1]
                    .replace(/=>/g, ":") // Replace `=>` with `:`
                    .replace(/"(\w+)"\s*:/g, '"$1":') // Ensure keys are quoted
                    .replace(/'/g, '"'); // Replace single quotes with double quotes
    
                // Parse the sanitized string
                const location = JSON.parse(`{${locationString}}`);
    
                filePath = location.file || "Unknown";
                startLine = location.start_line || "Unknown";

                row_params.push({vulnerability: vulnerability, severity: severity, filePath: filePath, startLine: startLine});
            } catch (error) {
                console.error(`Error parsing location for ID ${key}:`, error);
            }
        }
    });
    //console.log(row_params);
    
    const extractedData = [];

    Object.entries(desc_and_rec).map(([key, value]) => {
        // Define regex patterns
        const descriptionRegex = /Description:\n\n([\s\S]*?)\n\nRecommendations:/;
        const recommendationsRegex = /Recommendations:\n\n([\s\S]*)/;
        const codeBlockRegex = /```(?:javascript)?\n([\s\S]*?)\n```/;

        // Match using regex
        const descriptionMatch = value.match(descriptionRegex);
        const recommendationsMatch = value.match(recommendationsRegex);
        const codeBlockMatch = value.match(codeBlockRegex);

        // Extract values or set defaults
        const description = descriptionMatch ? descriptionMatch[1].trim() : "No description found";
        const recommendations = recommendationsMatch ? recommendationsMatch[1].trim() : "No recommendations found";
        const codeBlock = codeBlockMatch ? codeBlockMatch[1].trim() : "No code block found";

        // Push extracted data into the result array
        extractedData.push({
            description: description,
            recommendations: recommendations,
            codeBlock: codeBlock,
        });
    });

// Now `extractedData` contains the parsed rows
    console.log(desc_and_rec[1]);


    

    //console.log("Description:", description);
    //console.log("Recommendations:", recommendations);

    //console.log(recommendations);


    

    let vulnerabilities = Object.entries(rows).map(([key, row]) => ({
        id: parseInt(key, 10), // Auto-generate an ID based on index
        name: row_params[parseInt(key, 10) - 1].vulnerability, // Example name
        file_path: row_params[parseInt(key, 10) - 1].filePath, // Use the file_path from rows
        description: extractedData[parseInt(key, 10) - 1].description, // Default description
        severity: row_params[parseInt(key, 10) - 1].severity, // Fallback severity
        recomendation: extractedData[parseInt(key, 10) - 1].recommendations, // Default recommendation
        problematic_code: codes[parseInt(key, 10)], // Default problematic code
        possible_solution: extractedData[parseInt(key, 10) - 1].codeBlock, // Default possible solution
        line_number: row_params[parseInt(key, 10) - 1].startLine,
        live_demo: demos[parseInt(key, 10)], // Randomly generate a line number (example)
    }));

    //console.log(vulnerabilities);
    
	return {
		vulnerabilities: vulnerabilities,
	};
}

