import requests
import openai
import json
import re
import logging
import sys
import os

# Target base URL of the Juice Shop application
BASE_URL = "http://localhost:3000"  # Replace with the running application's URL

# Vulnerability details
vulnerability_details = {
    "vulnerability": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
    "cwe": "CWE-22",
    "details": """
    The application dynamically constructs file or path information. If the path
    information comes from user-supplied input, it could be abused to read sensitive files,
    access other users' data, or aid in exploitation to gain further system access.

    User input should never be used in constructing paths or files for interacting
    with the filesystem. This includes filenames supplied by user uploads or downloads.
    If possible, consider hashing user input or using unique values and
    use path.normalize to resolve and validate the path information
    prior to processing any file functionality.

    Example using path.normalize and not allowing direct user input:
    ```
    // User input, saved only as a reference
    // id is a randomly generated UUID to be used as the filename
    const userData = {userFilename: userSuppliedFilename, id: crypto.randomUUID()};
    // Restrict all file processing to this directory only
    const basePath = '/app/restricted/';

    // Create the full path, but only use our random generated id as the filename
    const joinedPath = path.join(basePath, userData.id);
    // Normalize path, removing any '..'
    const fullPath = path.normalize(joinedPath);
    // Verify the fullPath is contained within our basePath
    if (!fullPath.startsWith(basePath)) {
        console.log("Invalid path specified!");
    }
    // Process / work with file
    // ...
    ```

    For more information on path traversal issues see OWASP:
    https://owasp.org/www-community/attacks/Path_Traversal
    """,
    "example_code": """
    const files = await fs.readdir(currPath);
    const moreMatches = await findFilesWithCodeChallenges(
        files.map(file => path.resolve(currPath, file))
    );
    matches.push(...moreMatches);

    try {
        const code = await fs.readFile(currPath, 'utf8');
        if (
            code.includes('// vuln-code-snippet start') || 
            code.includes('# vuln-code-snippet start')
        ) {
            matches.push({ path: currPath, content: code });
        }
    } catch (e) {
        logger.warn(`File ${currPath} could not be read. It might have been moved or deleted. If coding challenges are contained in the file, they will not be available.`);
    }
    """,
    "severity": "Medium",
    "detected_at": "2024-11-14 15:16:30 UTC",
    "tool": "sast",
    "location": {
        "file": "lib/codingChallenges.ts",
        "start_line": 21
    },
    "other_identifiers": [
        "A5:2017 - Broken Access Control",
        "A01:2021 - Broken Access Control",
        "ESLint rule ID: detect-non-literal-fs-filename",
        "eslint.detect-non-literal-fs-filename"
    ],
    "additional_info": """
    This vulnerability allows attackers to exploit improper path handling to access unauthorized resources. 
    Proper sanitization and validation of user inputs are necessary to mitigate such risks.
    """
}


# Step 1: Generate payloads
# def generate_payloads(vulnerability_details):
#     prompt = f"""
# Based on the following vulnerability details:

# Vulnerability: {vulnerability_details['vulnerability']}
# CWE: {vulnerability_details['cwe']}
# Details: {vulnerability_details['details']}
# Example Code:
# {vulnerability_details['example_code']}

# Generate exactly 10 test payloads as a JSON array. Each payload should be a single JSON object.
# """

#     # Retrieve the OpenAI API key from an environment variable
#     openai.api_key = "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"  # Replace with your OpenAI API key

#     if not openai.api_key:
#         logging.error("OpenAI API key not found. Please set the OPENAI_API_KEY environment variable.")
#         sys.exit(1)

#     try:
#         response = openai.ChatCompletion.create(
#             model="gpt-4",
#             max_tokens=1000,  # Adjusted to allow for longer responses
#             messages=[
#                 {"role": "system", "content": "You are a cybersecurity expert specialized in penetration testing."},
#                 {"role": "user", "content": prompt}
#             ]
#         )

#         if 'choices' not in response or not response['choices']:
#             logging.error("OpenAI API returned an empty response.")
#             return []

#         raw_response = response['choices'][0]['message']['content'].strip()
#         print(f"Raw OpenAI API Response:\n{raw_response}\n")

#         # Try to parse the JSON array directly
#         try:
#             payloads = json.loads(raw_response)
#             if isinstance(payloads, list):
#                 return payloads
#             else:
#                 logging.error("Expected a JSON array but got a different type.")
#                 return []
#         except json.JSONDecodeError as e:
#             logging.error(f"JSON decoding failed: {e}")

#             # If direct parsing fails, attempt to extract the JSON array from the response
#             try:
#                 json_array_match = re.search(r'\[.*\]', raw_response, re.DOTALL)
#                 if json_array_match:
#                     json_array_str = json_array_match.group(0)
#                     payloads = json.loads(json_array_str)
#                     return payloads if isinstance(payloads, list) else []
#                 else:
#                     # Attempt to parse individual JSON objects
#                     payloads = re.findall(r'\{.*?\}', raw_response, re.DOTALL)
#                     payloads = [json.loads(p) for p in payloads]
#                     return payloads
#             except Exception as ex:
#                 logging.error(f"Failed to extract JSON payloads: {ex}")
#                 return []

#     except openai.error.OpenAIError as e:
#         logging.error(f"OpenAI API error: {e}")
#         return []

# Step 2: Test the endpoint with generated payloads
def test_nosql_injection(base_url, endpoint, payloads):
    results = []

    # Iterate over payloads
    for payload in payloads:
        # Construct the full URL
        test_url = base_url + endpoint.format(id="")

        # Send a POST request with the payload
        response = requests.post(
            test_url,
            json=payload,  # Inject payload
            headers={"Content-Type": "application/json"}
        )

        # Print and store the result
        # print(f"Payload: {payload}")
        # print(f"Status Code: {response.status_code}")
        # print(f"Response: {response.text}\n")

        # Append results for further processing
        results.append({
            "payload": payload,
            "status_code": response.status_code,
            "response": response.text
        })

    return results


param = sys.argv[1]
# print(param)

cleaned_content = param.replace("```json", "").replace("```", "").strip()
if not cleaned_content.startswith("["):
    cleaned_content = param.replace("Content: ```json", "").replace("```", "").strip()
# print(cleaned_content)

# Step 2: Parse the cleaned JSON string
json_array = json.loads(cleaned_content)
# print(json_array)

# Step 3: Extract only the "input" values into a list
payloads = [item["input"] for item in json_array]
# print(payloads)

# Main execution
if __name__ == "__main__":
    # Replace with the actual route if known
    endpoint_to_test = "/"  # Ensure it matches the route pattern

    # Generate payloads using OpenAI API
    PAYLOADS = payloads

    if not PAYLOADS:
        print("No payloads were generated.")
        sys.exit(1)

    # Test the endpoint with the generated payloads
    results = test_nosql_injection(BASE_URL, endpoint_to_test, PAYLOADS)

    # Output the results summary
    print("Summary of Test Results:\n")
    for result in results:
        print(f"Payload: {result['payload']}")
        print(f"Status Code: {result['status_code']}")
        print(f"Response: {result['response']}\n")
