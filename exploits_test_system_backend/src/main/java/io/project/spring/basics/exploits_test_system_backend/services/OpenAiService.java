package io.project.spring.basics.exploits_test_system_backend.services;

import com.fasterxml.jackson.databind.ObjectMapper;
import okhttp3.*;
import org.json.JSONArray;
import org.json.JSONObject;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class OpenAiService {
    private  final String API_KEY = "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";
    private final String OPENAI_API_URL = "https://api.openai.com/v1/chat/completions";

    private  String ai_model = "gpt-4o-mini";
    private  String desc_and_rec_system_prompt ="You are an IT cybersecurity expert specializing in penetration testing. Using the provided data, analyze and explain the vulnerability in detail, including its origins, consequences, and associated bad coding practices. Then, recommend robust coding practices and mitigation techniques to prevent such vulnerabilities in the future.";
    private  String desc_and_rec_user_prompt = "{\"code\":\" const newQuantity = product.quantity - BasketItem.quantity\\n QuantityModel.update({ quantity: newQuantity }, { where: { ProductId: BasketItem?.ProductId } }).catch((error: unknown) => {\\n next(error)\\n })\\n }).catch((error: unknown) => {\\n next(error)\\n })\\n let itemPrice: number\\n if (security.isDeluxe(req)) {\\n itemPrice = deluxePrice\\n } else {\\n itemPrice = price\\n }\\n const itemTotal = itemPrice * BasketItem.quantity\\n const itemBonus = Math.round(itemPrice / 10) * BasketItem.quantity\\n const product = {\\n quantity: BasketItem.quantity,\\n id,\\n name: req.__(name),\\n price: itemPrice,\\n total: itemTotal,\\n bonus: itemBonus\\n }\\n basketProducts.push(product)\\n doc.text(`${BasketItem.quantity}x ${req.__(name)} ${req.__('ea.')} ${itemPrice} = ${itemTotal}¤`)\\n doc.moveDown()\\n totalPrice += itemTotal\\n totalPoints += itemBonus\\n }\\n })\\n doc.moveDown()\\n const discount = calculateApplicableDiscount(basket, req)\\n let discountAmount = '0'\\n if (discount > 0) {\\n discountAmount = (totalPrice * (discount / 100)).toFixed(2)\\n doc.text(discount + '% discount from coupon: -' + discountAmount + '¤')\\n doc.moveDown()\\n totalPrice -= parseFloat(discountAmount)\\n }\\n const deliveryMethod = {\\n deluxePrice: 0,\\n price: 0,\\n eta: 5\\n }\\n if (req.body.orderDetails?.deliveryMethodId) {\\n const deliveryMethodFromModel = await DeliveryModel.findOne({ where: { id: req.body.orderDetails.deliveryMethodId } })\\n if (deliveryMethodFromModel != null) {\\n deliveryMethod.deluxePrice = deliveryMethodFromModel.deluxePrice\\n deliveryMethod.price = deliveryMethodFromModel.price\\n deliveryMethod.eta = deliveryMethodFromModel.eta\\n }\\n }\\n const deliveryAmount = security.isDeluxe(req) ? deliveryMethod.deluxePrice : deliveryMethod.price\\n totalPrice += deliveryAmount\\n doc.text(`${req.__('Delivery Price')}: ${deliveryAmount.toFixed(2)}¤`)\\n doc.moveDown()\\n doc.font('Helvetica-Bold', 20).text(`${req.__('Total Price')}: ${totalPrice.toFixed(2)}¤`)\\n doc.moveDown()\\n doc.font('Helvetica-Bold', 15).text(`${req.__('Bonus Points Earned')}: ${totalPoints}`)\\n doc.font('Times-Roman', 15).text(`(${req.__('The bonus points from this order will be added 1:1 to your wallet ¤-fund for future purchases!')}`)\\n doc.moveDown()\\n doc.moveDown()\\n doc.font('Times-Roman', 15).text(req.__('Thank you for your order!'))\\n\\n challengeUtils.solveIf(challenges.negativeOrderChallenge, () => { return totalPrice < 0 })\\n\\n if (req.body.UserId) {\\n if (req.body.orderDetails && req.body.orderDetails.paymentId === 'wallet') {\\n const wallet = await WalletModel.findOne({ where: { UserId: req.body.UserId } })\\n if ((wallet != null) && wallet.balance >= totalPrice) {\\n WalletModel.decrement({ balance: totalPrice }, { where: { UserId: req.body.UserId } }).catch((error: unknown) => {\\n next(error)\\n })\\n } else {\\n next(new Error('Insufficient wallet balance.'))\\n }\\n }\\n WalletModel.increment({ balance: totalPoints }, { where: { UserId: req.body.UserId } }).catch((error: unknown) => {\\n next(error)\\n })\\n }\\n\\n db.ordersCollection.insert({\\n promotionalAmount: discountAmount,\\n paymentId: req.body.orderDetails ? req.body.orderDetails.paymentId : null,\\n addressId: req.body.orderDetails ? req.body.orderDetails.addressId : null,\\n orderId,\\n delivered: false,\\n email: (email ? email.replace(/[aeiou]/gi, '*') : undefined),\\n totalPrice,\\n products: basketProducts,\\n bonus: totalPoints,\\n deliveryPrice: deliveryAmount,\\n eta: deliveryMethod.eta.toString()\\n }).then(() => {\\n doc.end()\\n })\\n } else {\\n next(new Error(`Basket with id=${id} does not exist.`))\\n }\\n }).catch((error: unknown) => {\\n next(error)\\n })\\n }\\n}\\n\\nfunction calculateApplicableDiscount (basket: BasketModel, req: Request) {\\n if (security.discountFromCoupon(basket.coupon)) {\\n const discount = security.discountFromCoupon(basket.coupon)\\n challengeUtils.solveIf(challenges.forgedCouponChallenge, () => { return discount >= 80 })\\n return discount\\n } else if (req.body.couponData) {\\n const couponData = Buffer.from(req.body.couponData, 'base64').toString().split('-')\\n const couponCode = couponData[0]\\n constcouponDate = Number(couponData[1])\\n const campaign = campaigns[couponCode as keyof typeof campaigns]\\n\\n if (campaign && couponDate == campaign.validOn) { // eslint-disable-line eqeqeq\\n challengeUtils.solveIf(challenges.manipulateClockChallenge, () => { return campaign.validOn < new Date().getTime() })\\n return campaign.discount\\n }\\n }\\n return 0\\n}\\n\\nconst campaigns = {\\n WMNSDY2019: { validOn: new Date('Mar 08, 2019 00:00:00 GMT+0100').getTime(), discount: 75 },\\n WMNSDY2020: { validOn: new Date('Mar 08, 2020 00:00:00 GMT+0100').getTime(), discount: 60 },\\n WMNSDY2021: { validOn: new Date('Mar 08, 2021 00:00:00 GMT+0100').getTime(), discount: 60 },\\n WMNSDY2022: { validOn: new Date('Mar 08, 2022 00:00:00 GMT+0100').getTime(), discount: 60 },\\n WMNSDY2023: { validOn: new Date('Mar 08, 2023 00:00:00 GMT+0100').getTime(), discount: 60 },\\n ORANGE2020: { validOn: new Date('May 04, 2020 00:00:00 GMT+0100').getTime(), discount: 50 },\\n ORANGE2021: { validOn: new Date('May 04, 2021 00:00:00 GMT+0100').getTime(), discount: 40 },\\n ORANGE2022: { validOn: new Date('May 04, 2022 00:00:00 GMT+0100').getTime(), discount: 40 },\\n ORANGE2023: { validOn: new Date('May 04, 2023 00:00:00 GMT+0100').getTime(), discount: 40 }\\n}\",\"row\":\"{Status=detected, Scanner Name=Semgrep, Full Path=, Comments=, Activity=FALSE, Vulnerability=Improper neutralization of special elements in data query logic, Severity=critical, Project Name=juice-shop, CWE=CWE-943, Other Identifiers=\\\"A1:2017 - Injection\\\"; nodejs_scan.javascript-database-rule-node_nosqli_injection; \\\"NodeJS Scan ID javascript-database-rule-node_nosqli_injection\\\"; \\\"A03:2021 - Injection\\\", CVSS Vectors=, Dismissal Reason=, Details=Untrusted user input in findOne() function can result in NoSQL Injection.\\\\n, CVE=, Group Name=, Additional Info=, Detected At=2024-11-14 15:16:30 UTC, Tool=sast, Location={\\\"file\\\"=>\\\"routes/order.ts\\\", \\\"start_line\\\"=>71}}\"}\n" +
            "Given the following data:\n" +
            "Code Part: The code snippet where the vulnerability occurs.\n" +
            "Row Part: Information about the vulnerability detected on a website.\n" +
            "Based on this data, write two sections: Description and Recommendations.\n" +
            "Description:\n" +
            "Overall Description: Provide a general explanation of the vulnerability. Include:\n" +
            "What this vulnerability is.(2 sentences)\n" +
            "How it works in general.(2 sentences)\n" +
            "Why it is dangerous. (2 sentences)\n" +
            "Origin and Consequences: Explain:\n" +
            "How the vulnerability originated in the given code.(3 sentences) (in text are code examples)\n" +
            "The impact and consequences of exploiting this vulnerability.(2 sentences)\n" +
            "Bad Practices: Identify:\n" +
            "Specific coding practices that lead to this vulnerability. (1 sentence)\n" +
            "Examples of what not to do in code. (2 sentences)\n" +
            "Recommendations :\n" +
            "Provide detailed guidance on how to:\n" +
            "How to prevent this type of vulnerability in the code. (5 sentences)\n" +
            "Replace the vulnerable code with safer alternatives. (write all important parts of code)\n" +
            "On the end find out what is the language of given code. Write this in that format: language: java.\n" +
            "All section: Description, Recommendations, language are divided with signs: \"##########\" (# 10-times above section: Description, Recommendations, language) and 1 empty line above\n" +
            "Also, make all text well structed: should be written all sections and subsections mentioned above.";

    private String payloads_system_prompt = "You are a cybersecurity expert specialized in penetration testing.";
    private String payloads_user_prompt = "Based on the following vulnerability details:\n" +
            "\n" +
            "{Status=detected, Scanner Name=Semgrep, Full Path=, Comments=, Activity=FALSE, Vulnerability=Improper neutralization of special elements in data query logic, Severity=critical, Project Name=juice-shop, CWE=CWE-943, Other Identifiers=\\\"A1:2017 - Injection\\\"; nodejs_scan.javascript-database-rule-node_nosqli_injection; \\\"NodeJS Scan ID javascript-database-rule-node_nosqli_injection\\\"; \\\"A03:2021 - Injection\\\", CVSS Vectors=, Dismissal Reason=, Details=Untrusted user input in findOne() function can result in NoSQL Injection.\\\\n, CVE=, Group Name=, Additional Info=, Detected At=2024-11-14 15:16:30 UTC, Tool=sast, Location={\\\"file\\\"=>\\\"routes/order.ts\\\", \\\"start_line\\\"=>71}}" +
            "Example Code:\n" +
            "const newQuantity = product.quantity - BasketItem.quantity\\n QuantityModel.update({ quantity: newQuantity }, { where: { ProductId: BasketItem?.ProductId } }).catch((error: unknown) => {\\n next(error)\\n })\\n }).catch((error: unknown) => {\\n next(error)\\n })\\n let itemPrice: number\\n if (security.isDeluxe(req)) {\\n itemPrice = deluxePrice\\n } else {\\n itemPrice = price\\n }\\n const itemTotal = itemPrice * BasketItem.quantity\\n const itemBonus = Math.round(itemPrice / 10) * BasketItem.quantity\\n const product = {\\n quantity: BasketItem.quantity,\\n id,\\n name: req.__(name),\\n price: itemPrice,\\n total: itemTotal,\\n bonus: itemBonus\\n }\\n basketProducts.push(product)\\n doc.text(`${BasketItem.quantity}x ${req.__(name)} ${req.__('ea.')} ${itemPrice} = ${itemTotal}¤`)\\n doc.moveDown()\\n totalPrice += itemTotal\\n totalPoints += itemBonus\\n }\\n })\\n doc.moveDown()\\n const discount = calculateApplicableDiscount(basket, req)\\n let discountAmount = '0'\\n if (discount > 0) {\\n discountAmount = (totalPrice * (discount / 100)).toFixed(2)\\n doc.text(discount + '% discount from coupon: -' + discountAmount + '¤')\\n doc.moveDown()\\n totalPrice -= parseFloat(discountAmount)\\n }\\n const deliveryMethod = {\\n deluxePrice: 0,\\n price: 0,\\n eta: 5\\n }\\n if (req.body.orderDetails?.deliveryMethodId) {\\n const deliveryMethodFromModel = await DeliveryModel.findOne({ where: { id: req.body.orderDetails.deliveryMethodId } })\\n if (deliveryMethodFromModel != null) {\\n deliveryMethod.deluxePrice = deliveryMethodFromModel.deluxePrice\\n deliveryMethod.price = deliveryMethodFromModel.price\\n deliveryMethod.eta = deliveryMethodFromModel.eta\\n }\\n }\\n const deliveryAmount = security.isDeluxe(req) ? deliveryMethod.deluxePrice : deliveryMethod.price\\n totalPrice += deliveryAmount\\n doc.text(`${req.__('Delivery Price')}: ${deliveryAmount.toFixed(2)}¤`)\\n doc.moveDown()\\n doc.font('Helvetica-Bold', 20).text(`${req.__('Total Price')}: ${totalPrice.toFixed(2)}¤`)\\n doc.moveDown()\\n doc.font('Helvetica-Bold', 15).text(`${req.__('Bonus Points Earned')}: ${totalPoints}`)\\n doc.font('Times-Roman', 15).text(`(${req.__('The bonus points from this order will be added 1:1 to your wallet ¤-fund for future purchases!')}`)\\n doc.moveDown()\\n doc.moveDown()\\n doc.font('Times-Roman', 15).text(req.__('Thank you for your order!'))\\n\\n challengeUtils.solveIf(challenges.negativeOrderChallenge, () => { return totalPrice < 0 })\\n\\n if (req.body.UserId) {\\n if (req.body.orderDetails && req.body.orderDetails.paymentId === 'wallet') {\\n const wallet = await WalletModel.findOne({ where: { UserId: req.body.UserId } })\\n if ((wallet != null) && wallet.balance >= totalPrice) {\\n WalletModel.decrement({ balance: totalPrice }, { where: { UserId: req.body.UserId } }).catch((error: unknown) => {\\n next(error)\\n })\\n } else {\\n next(new Error('Insufficient wallet balance.'))\\n }\\n }\\n WalletModel.increment({ balance: totalPoints }, { where: { UserId: req.body.UserId } }).catch((error: unknown) => {\\n next(error)\\n })\\n }\\n\\n db.ordersCollection.insert({\\n promotionalAmount: discountAmount,\\n paymentId: req.body.orderDetails ? req.body.orderDetails.paymentId : null,\\n addressId: req.body.orderDetails ? req.body.orderDetails.addressId : null,\\n orderId,\\n delivered: false,\\n email: (email ? email.replace(/[aeiou]/gi, '*') : undefined),\\n totalPrice,\\n products: basketProducts,\\n bonus: totalPoints,\\n deliveryPrice: deliveryAmount,\\n eta: deliveryMethod.eta.toString()\\n }).then(() => {\\n doc.end()\\n })\\n } else {\\n next(new Error(`Basket with id=${id} does not exist.`))\\n }\\n }).catch((error: unknown) => {\\n next(error)\\n })\\n }\\n}\\n\\nfunction calculateApplicableDiscount (basket: BasketModel, req: Request) {\\n if (security.discountFromCoupon(basket.coupon)) {\\n const discount = security.discountFromCoupon(basket.coupon)\\n challengeUtils.solveIf(challenges.forgedCouponChallenge, () => { return discount >= 80 })\\n return discount\\n } else if (req.body.couponData) {\\n const couponData = Buffer.from(req.body.couponData, 'base64').toString().split('-')\\n const couponCode = couponData[0]\\n constcouponDate = Number(couponData[1])\\n const campaign = campaigns[couponCode as keyof typeof campaigns]\\n\\n if (campaign && couponDate == campaign.validOn) { // eslint-disable-line eqeqeq\\n challengeUtils.solveIf(challenges.manipulateClockChallenge, () => { return campaign.validOn < new Date().getTime() })\\n return campaign.discount\\n }\\n }\\n return 0\\n}\\n\\nconst campaigns = {\\n WMNSDY2019: { validOn: new Date('Mar 08, 2019 00:00:00 GMT+0100').getTime(), discount: 75 },\\n WMNSDY2020: { validOn: new Date('Mar 08, 2020 00:00:00 GMT+0100').getTime(), discount: 60 },\\n WMNSDY2021: { validOn: new Date('Mar 08, 2021 00:00:00 GMT+0100').getTime(), discount: 60 },\\n WMNSDY2022: { validOn: new Date('Mar 08, 2022 00:00:00 GMT+0100').getTime(), discount: 60 },\\n WMNSDY2023: { validOn: new Date('Mar 08, 2023 00:00:00 GMT+0100').getTime(), discount: 60 },\\n ORANGE2020: { validOn: new Date('May 04, 2020 00:00:00 GMT+0100').getTime(), discount: 50 },\\n ORANGE2021: { validOn: new Date('May 04, 2021 00:00:00 GMT+0100').getTime(), discount: 40 },\\n ORANGE2022: { validOn: new Date('May 04, 2022 00:00:00 GMT+0100').getTime(), discount: 40 },\\n ORANGE2023: { validOn: new Date('May 04, 2023 00:00:00 GMT+0100').getTime(), discount: 40 }\\n}" +
            "\n" +
            "Generate exactly 10 test payloads as a JSON array. Each payload should be a single JSON object. Write me only a list of payloads!!!! Nothing else!!!";

    public String generateCompletion(String model, String systemPrompt, String userPrompt) {
        try {
            // Create headers
            HttpHeaders headers = new HttpHeaders();
            headers.set("Content-Type", "application/json");
            headers.set("Authorization", "Bearer " + API_KEY);

            // Use a Map to dynamically build the request body
            ObjectMapper objectMapper = new ObjectMapper();
            Map<String, Object> requestBody = new HashMap<>();
            requestBody.put("model", model);

            // Construct messages array
            List<Map<String, String>> messages = new ArrayList<>();
            messages.add(Map.of("role", "system", "content", systemPrompt));
            messages.add(Map.of("role", "user", "content", userPrompt));
            requestBody.put("messages", messages);

            // Serialize the request body into JSON
            String requestBodyJson = objectMapper.writeValueAsString(requestBody);

            // Create HttpEntity with headers and JSON body
            HttpEntity<String> request = new HttpEntity<>(requestBodyJson, headers);

            // Use RestTemplate to send the request
            RestTemplate restTemplate = new RestTemplate();
            ResponseEntity<String> response = restTemplate.exchange(
                    OPENAI_API_URL,
                    HttpMethod.POST,
                    request,
                    String.class
            );

            // Return the response body
            return response.getBody();

        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Error generating completion: " + e.getMessage());
        }
    }

    public String genDescAndRec() {
        return generateCompletion(ai_model, desc_and_rec_system_prompt, desc_and_rec_user_prompt);
    }

    public String getPayloads() {
        return generateCompletion(ai_model, payloads_system_prompt, payloads_user_prompt);
    }
}
