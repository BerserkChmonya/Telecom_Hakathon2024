package io.project.spring.basics.exploits_test_system_backend.services;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class DataService {

    @Autowired
    private GitService gitService;
    @Autowired
    private OpenAiService openAiService;

    public String getTestString() {
        return "Test string";
    }


    public List<Map<String, String>> processCsvFile(MultipartFile file) throws Exception {
        List<Map<String, String>> result = new ArrayList<>();

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(file.getInputStream()))) {
            Iterable<CSVRecord> records = CSVFormat.DEFAULT.withFirstRecordAsHeader().parse(reader);

            // Iterate over the CSV records
            for (CSVRecord record : records) {
                Map<String, String> rowData = new HashMap<>();

                // Iterate over each header column in the CSV and extract the value from the record
                for (String header : record.toMap().keySet()) {
                    String value = record.get(header);

                    // Handle null or empty columns (trim whitespace)
                    if (value != null) {
                        value = value.trim();
                    } else {
                        value = "";  // Set to empty string if null
                    }

                    rowData.put(header, value);
                }
                result.add(rowData);
            }
        } catch (IOException e) {
            e.printStackTrace();
            throw new Exception("Error processing the file: " + e.getMessage());
        }

        return result;
    }


    public List<String> extractColumnFromProcessedCsv(MultipartFile file, String columnName) throws Exception {
        // Process the CSV file to get the List<Map<String, String>> data
        List<Map<String, String>> csvData = processCsvFile(file);

        List<String> columnData = new ArrayList<>();

        // Iterate over each row in the processed CSV data
        for (Map<String, String> row : csvData) {
            // Check if the column exists in the row
            if (row.containsKey(columnName)) {
                String value = row.get(columnName);
                columnData.add(value);  // Add the value of the column to the list
            } else {
                columnData.add("");  // If column doesn't exist, add empty string
            }
        }

        return columnData;  // Return the list of column values
    }

    public Map<String, String> extractRowByNumber(MultipartFile file, int rowNumber) throws Exception {
        // Process the CSV file to get the List<Map<String, String>> data
        List<Map<String, String>> csvData = processCsvFile(file);

        // Validate the row number
        if (rowNumber < 0 || rowNumber >= csvData.size()) {
            throw new IllegalArgumentException("Row number out of range.");
        }

        // Get the specific row by index
        return csvData.get(rowNumber); // Return the map representing the row
    }

    public int getRowCount(MultipartFile file) throws Exception {
        // Process the CSV file to get the List<Map<String, String>> data
        List<Map<String, String>> csvData = processCsvFile(file);

        // Return the number of rows
        return csvData.size();
    }

    public Map<String, String> getDataInRow(
            MultipartFile file, int rowNumber, String owner, String repo) throws Exception {

        // Extract the specified row from the CSV
        Map<String, String> row = extractRowByNumber(file, rowNumber);

        // Extract the "Location" column value
        String location = row.get("Location");

        if (location == null || location.isEmpty()) {
            throw new IllegalArgumentException("Location column is empty or missing in the row.");
        }

        // Parse the location string into key-value pairs
        Map<String, String> codeLocation = new HashMap<>();
        String[] pairs = location.substring(1, location.length() - 1).split(", "); // Remove { and }

        // Iterate through key-value pairs
        for (String pair : pairs) {
            String[] keyValue = pair.split("=>");
            if (keyValue.length == 2) {
                String key = keyValue[0].replaceAll("[\"{}]", "").trim(); // Remove quotes and braces
                String value = keyValue[1].replaceAll("[\"{}]", "").trim(); // Remove quotes and braces
                codeLocation.put(key, value);
            }
        }

        // Extract file path and start line
        String filePath = codeLocation.get("file");
        String startLineStr = codeLocation.get("start_line");

        if (filePath == null || startLineStr == null) {
            throw new IllegalArgumentException("Missing file path or start line in the location data.");
        }
        int lineNum = Integer.parseInt(startLineStr);


        String[] codeLines = GitService.fetchFileContent(owner, repo, filePath, lineNum);

        Map<String, String> combinedData= new HashMap<>();

        combinedData.put("row", row.toString());
        combinedData.put("code", String.join("\n", codeLines));

        return combinedData;
    }
}
